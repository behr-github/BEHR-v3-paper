classdef behr_paths_template
    % behr_paths: paths used in the BEHR algorithm.
    %	Automatically generated by BEHR_initial_setup on 2017-08-07
    %
    %	A number of paths are stored in this class as constant properties
    %	that can be accessed directly from the class without an instance. A
    %	list of the paths can be printed by calling
    %	behr_paths.ListAvailablePaths().
    %
    %   This can also assist in setting up your Matlab search path to find
    %   all the BEHR code. See the behr_paths.AddCodePaths() method.
    %
    %	Note that this function should not be added to the BEHR git repo,
    %	as it must be specific to each person's computer. The first time
    %	this is created, you should check that all the paths are correct.
    %	You can verify they exists by calling the
    %	behr_paths.ValidatePaths() method.
    %
    %   Also note that this class should only rely on built-in Matlab
    %   function and not any code that comes with the BEHR or related
    %   repositories, since it needs to be callable before those functions
    %   are on the Matlab search path to help users set up the search path.
    
    % Each of the following paths needs to be a local path on your
    % computer. For the code repositories, you will want to clone those
    % from the file server onto your computer and point the path to that
    % cloned repository. For the data directories that are on the file
    % server, you will need to mount the file server as a network drive on
    % your computer and point the paths below to that mounted path. Network
    % drives mapped on windows have the drive letter you assign when you
    % map it; on Macs, they are usually found under the /Volumes path. If
    % you are working on a Linux computer you'll usually create mount
    % points under /mnt or similar - that is how the satellite download
    % computer is set up.
    %
    % If you're working with BEHR on a cluster, you likely won't need to
    % deal with networked drives, and everything will have a
    % straightforward path.
    %
    % Important note: the python automation that runs BEHR automatically
    % can't handle when a cell array containing multiple paths is split
    % over >1 line. If you need to split a cell array over multiple lines,
    % either don't or fix the Python program (currently in BEHR-Automation
    % repo: behr_automation.behr_runner.utils.BEHRPaths)
    
    properties(Constant=true)
        %#PATHS
    end
    
    properties(Constant=true, Access=private)
        %#ISFILE
        
        %#ISCODEDIR
    end
    
    methods(Static=true)
        function success = ValidatePaths(varargin)
            % BEHR_PATHS.ValidatePaths() checks that all the paths
            % specified as static properties of this class. Any paths that
            % are not directories (or files, if the private property
            % is_field_file is true for that path) are printed. This
            % function returns true if all paths a valid, false otherwise.
            %
            % BEHR_PATHS.ValidatePaths('codeonly') only verifies paths
            % marked internally a code directories that would be added to
            % the Matlab path by behr_paths.AddCodePaths().
            code_only = ismember('codeonly', varargin);
            
            fns = fieldnames(behr_paths);
            success = true;
            for a=1:numel(fns)
                if code_only && ~behr_paths.is_code_dir.(fns{a})
                    continue
                end
                
                if behr_paths.is_field_file.(fns{a})
                    test_type = 'file';
                else
                    test_type = 'dir';
                end
                if ~iscell(behr_paths.(fns{a}))
                    if ~exist(behr_paths.(fns{a}), test_type)
                        fprintf('%s is not a valid path\n', fns{a});
                        success = false;
                    end
                else
                    for b=1:numel(behr_paths.(fns{a}))
                        if ~exist(behr_paths.(fns{a}){b}, test_type)
                            fprintf('%s{%d} is not a valid path\n', fns{a}, b);
                            success = false;
                        end
                    end
                end
            end
        end
        
        function AddCodePaths(varargin)
            % BEHR_PATHS.AddCodePaths() will add all directories listed
            % internally as containing code to the Matlab search path. It
            % will ask interactively if you want to add the directories to
            % your Matlab path permanently.
            %
            % BEHR_PATHS.AddCodePaths('nosave')
            % BEHR_PATHS.AddCodePaths('save') both of these syntaxes
            % preempt the interactive question. 'nosave' indicates not to
            % save the new Matlab search path, 'save' indicates to save the
            % new Matlab search path.
            %
            % BEHR_PATHS.AddCodePaths( ___, 'quiet' ) suppresses printing
            % each path added. This can be used with any of the previous
            % syntaxes.
            be_quiet = ismember('quiet', varargin);
            ask_to_save = true;
            if ismember('nosave', varargin)
                ask_to_save = false;
                save_paths = false;
            elseif ismember('save', varargin)
                ask_to_save = false;
                save_paths = true;
            end
            
            if ~behr_paths.ValidatePaths('codeonly')
                error('path_setup:bad_paths', 'One or more directories specified as code paths are invalid')
            end
            
            if ask_to_save
                save_paths = strcmpi(input('Permanently add the BEHR code directories to your Matlab path (y to do so, any other answer will not)? ', 's'), 'y');
            end
            
            fns = fieldnames(behr_paths);
            for a=1:numel(fns)
                if behr_paths.is_code_dir.(fns{a})
                    if behr_paths.do_genpath.(fns{a})
                        paths_to_add = behr_paths.no_git(genpath(behr_paths.(fns{a})));
                        
                        print_paths = strsplit(paths_to_add,':');
                        if ~be_quiet
                            for b=1:numel(print_paths)
                                fprintf('Adding %s\n', print_paths{b});
                            end
                        end
                    else
                        paths_to_add = behr_paths.(fns{a});
                        if ~be_quiet
                            fprintf('Adding %s\n', paths_to_add);
                        end
                    end
                    addpath(paths_to_add);
                end
            end
            
            if save_paths
                savepath();
            elseif ~be_quiet
                fprintf('BEHR paths added to Matlab search path for this session only. To make the change permanent, use "savepath()"\n');
            end
        end
        
        function SetPythonPath(varargin)
            % BEHR_PATHS.SetPythonPath() modifies the Python search path
            % used by Matlab to include all paths marked as including
            % Python files.
            be_quiet = ismember('quiet', varargin);
            
            fns = fieldnames(behr_paths);
            for a=1:numel(fns)
                if behr_paths.is_pypath.(fns{a})
                    new_path = behr_paths.(fns{a});
                    if count(py.sys.path, new_path) == 0
                        if ~be_quiet
                            fprintf('Adding %s\n', new_path);
                        end
                        insert(py.sys.path, int32(0), new_path);
                    end
                end
            end
        end
        
        function ListAvailablePaths()
            % BEHR_PATHS.ListAvailablePaths() prints each path's property
            % name followed by the path it refers to.
            fns = fieldnames(behr_paths);
            fprintf('Available paths:\n');
            for a=1:numel(fns)
                if ~iscell(behr_paths.(fns{a}))
                    fprintf('  %s = %s\n', fns{a}, behr_paths.(fns{a}));
                else
                    fprintf('  %s = {%s}\n', fns{a}, strjoin(behr_paths.(fns{a}), ', '));
                end
            end
        end
        
        function d = SPMatSubdir(region)
            % BEHR_PATHS.SPMatSubdir( REGION ) returns the proper default
            % path for OMI_SP files produced for the given REGION.
            d = fullfile(behr_paths.sp_mat_dir, lower(region));
        end
        
        function d = BEHRMatSubdir(region, prof_mode)
            % BEHR_PATHS.BEHRMatSubdir( REGION, PROF_MODE ) returns the
            % proper default path for OMI_BEHR files produced for the given
            % REGION and PROF_MODE (profile mode, usually 'daily' or
            % 'monthly'
            d = fullfile(behr_paths.behr_mat_dir, lower(region), lower(prof_mode));
        end
        
        function d = BEHRUncertSubdir(region)
            d = fullfile(behr_paths.behr_mat_dir, sprintf('%s-uncertainty', lower(region)));
        end
    end
    
    methods(Static = true, Access = private)
        function p = no_git(p)
            if ischar(p)
                p = strsplit(p,':');
            elseif ~iscellstr(p)
                return
            end
            
            % If p is a cell array with only one element, then the return
            % from strcmp is not a cell array
            gg = strfind(p, '/.git');
            if iscell(gg)
                gg = cellfun('isempty', gg);
            end
            xx = gg & ~cellfun('isempty', p);
            p = strjoin(p(xx),':');
        end
    end
end