function [profiles_final, profiles_struct] = verify_sat_vs_aircraft_vcds(Data, Merge, campaign, varargin)
%VERIFY_SAT_VS_AIRCRAFT_VCDS Updated code to compare sat and aircraft VCDs
%   [ PROFILES_FINAL, PROFILES_STRUCT ] = VERIFY_SAT_VS_AIRCRAFT_VCDS(
%   DATA, MERGE, CAMPAIGN ) will match aircraft profiles with satellite
%   data and integrate the aircraft profiles to obtain in-situ VCDs. DATA
%   is a BEHR Data structure, MERGE is a Merge data structure containing
%   aircraft data (generated by read_merge_data() or read_icartt_file()),
%   and CAMPAIGN is a character array recognized by merge_field_names() as
%   a campaign name. This returns two structure; PROFILES_FINAL contains
%   the matched satellite and aircraft VCDs along with a few additional
%   fields that might be of interest when trying to understand the
%   agreement or disagreement between the two data sets. PROFILES_STRUCT
%   contains more detailed information on each profile matched to satellite
%   data.
%   
%   This function has a significant number of parameters that control its
%   behavior.
%
%   Main parameters:
%
%       'utc_range_file' - a file containing a Ranges structure (usually
%       created by the select_campaign_ranges.m script). If given, this
%       function identified profiles by the UTC ranges given in that file.
%       If not given, then the Merge data must include profile numbers
%       (i.e. it must be a DISCOVER-AQ campaign). This can be given either
%       as a full path to a file, or if it does not point to a file, then
%       it will be given to merge_field_names() as a regex, which if it
%       matches one of the files specified for that campaign, will generate
%       the full path automatically.
%
%       'no2_field' - either the char array 'no2_lif', 'no2_ncar', or an
%       empty string. If an empty string is given (default), this function
%       will choose which field to use, preferring the LIF instrument.
%
%       'DEBUG_LEVEL' - a scalar number controlling how much printing to
%       screen this function does. Default is 2, 0 means nothing.
%
%   Profile rejection parameters:
%
%       'min_radar_alt' - an altitude (in kilometers) that the minimum
%       radar altitude of a profile must be below in order for that profile
%       to be included; this is one criteria used to ensure that a profile
%       samples sufficiently close to the surface. Default is 0.5,
%       recommended by Hains et al. 2010.
%
%       'number_bl_points' - the minimum number of valid (i.e. not a fill
%       value) 1 second data points that must be included below 3 km. This
%       ensures adequate sampling of the boundary layer and the transition
%       to the free troposphere. Default is 20, recommended by Hains et al.
%       2010.
%
%       'min_height' - the minimum difference (in km) required between the
%       bottom and top of the profile. Default is 0, i.e. not used.
%
%   Matching parameters:
%
%       'time_range' - the time (in hours) to either side of OMI overpass
%       that a profile may be used. OMI overpass is calculated as the
%       average over all pixels retrieved in that orbit by BEHR. Default is
%       1.5, i.e. if OMI overpass was exactly 13:30, then any profiles made
%       between 12:00 and 15:00 would be used. The profile time is also
%       calculated as the average of all times in the profile.
%
%       'min_frac_in_pixel' - the minimum fraction of valid points in the
%       profile that must fall within a pixel in order for that pixel to be
%       included in the average VCD matched with the profile. Default is 0,
%       i.e. this criterion is not enforced. But, for example, one could
%       require that at least 10% of the measurements in a profile fall
%       within a pixel by passing 0.1 to this parameter.
%
%       'min_points_in_pixel' - the minimum number of valid points in the
%       profile that must fall within a pixel in order for that pixel to be
%       included in the average VCD matched with the profile. Default is 1,
%       i.e. any pixel intersected by the profile is included. In order for
%       a pixel to be included, it must pass BOTH this and the
%       min_frac_in_pixel criteria.
%
%       'match_bl_only' - controls whether to only match pixels that the
%       boundary layer part of the profile overlaps. This is by default 0,
%       which turns this feature off. Values greater than 0 give the
%       altitude below which points are counted as in the boundary layer.
%       This altitude is compared to the radar altitude, so they must be in
%       the same units. Example, assuming radar altitude is in kilometers,
%       then if this is set to 3 only aircraft measurements below 3 km will
%       be used in determining which pixels to compare against.
%
%   Integration parameters:
%
%       'prof_extension' - a char array, either 'extrap' (default), 'wrf',
%       or 'geos' that controls how to extend profiles that do not reach
%       the tropopause or the surface. 'extrap' will extrapolate the top
%       and bottom 10 measurements as in Hains et al. 2010; 'wrf' or 'geos'
%       will use WRF-Chem or GEOS-Chem profiles more similarly to Lamsal et
%       al. 2014.
%
%       'wrf_prof_mode' - a char array, either an empty one, 'monthly', or
%       'daily' that determines which WRF output to use to extrapolate the
%       aircraft profiles to the tropopause and the surface. Extrapolation
%       is done as in Lamsal et al. 2014. If empty, the mode is set to be
%       the same as the profile mode used to generate the BEHR Data struct.
%       Only has an effect if 'prof_extension' is set to 'wrf'.
%
%       'gc_data_dir' - the directory to load GEOS-Chem ND51 diagnostic
%       output files from. These are currently assumed to be translated
%       from binary punch format into netCDF by gc_nd51_to_ncdf.py in the
%       GEOS-Chem-Utils repo (rather than directly output to netCDF by
%       GEOS-Chem). Only has an effect is 'prof_extension' is set to
%       'geos'.
%
%       'gc_data_year' - the year for which GEOS-Chem data is available. By
%       default, this looks for GEOS-Chem data from the exact day that the
%       aircraft flew. If GEOS-Chem data is only available for one year,
%       pass that year (as a number) here to always used that year. Only
%       has an effect if 'prof_extension' is set to 'geos'.
%
%       'detection_limit' - the detection limit of the NO2 instrument used,
%       given in mixing ratio (parts-per-part). Default is 3e-12, i.e. 3
%       pptv, as in Hains et al. 2010. This is used in extrapolating; if
%       the median of the top ten values is below this limit, it is set to
%       half this limit. Only used if 'prof_extension' is set to 'extrap'.
%
%       'ignore_top_check' - if true (default) the median of the top ten
%       NO2 measurements is checked if it is greater than 100 pptv. If so,
%       the profile is rejected on the assumption that it did not sample
%       the free troposphere. Set to false to include such profiles, though
%       be aware that extrapolating such values may dramatically
%       overestimate the total NO2 column. Only used if 'prof_extension' is
%       set to 'extrap'.

E = JLLErrors;

% Note: additional parameters are defined in several of the subfunctions
p = inputParser;
p.addParameter('utc_range_file','');
p.addParameter('no2_field','');
p.addParameter('DEBUG_LEVEL', 2);
p.KeepUnmatched = true;

p.parse(varargin{:});
pout = p.Results;

utc_range_file = pout.utc_range_file;
no2_field = set_no2_field(pout.no2_field, campaign);
DEBUG_LEVEL = pout.DEBUG_LEVEL;

%%%%%%%%%%%%%%%%%
% MAIN FUNCTION %
%%%%%%%%%%%%%%%%%

% Get a structure that has all available profiles in the Merge structure
% Define these for the collect_profiles nested functions Give the variables
% to read in as a struct where the field name is the field name in
% merge_names and the value is a structure containing the desired unit and
% the field name in the structure returned by merge_field_names() that
% contains the actual variable name in the Merge structure. An empty string
% means do not convert the unit. REMOVE_MERGE_FILLS automatically corrects
% the sign of longitude data.
merge_variables = struct('longitude', struct('unit', '', 'merge_fn', 'longitude'),...
                         'latitude', struct('unit', '', 'merge_fn', 'latitude'),...
                         'pressure', struct('unit', 'hPa', 'merge_fn', 'pressure'),...
                         'pressure_alt', struct('unit', 'km', 'merge_fn', 'pressure_alt'),...
                         'radar_alt', struct('unit', 'km', 'merge_fn', 'radar_alt'),...
                         'no2', struct('unit', 'ppp', 'merge_fn', no2_field),...
                         'utc', struct('unit', '', 'merge_fn', 'utc'));
merge_variable_names = fieldnames(merge_variables);

if isempty(utc_range_file)
    profiles_struct = collect_profiles_by_number(Merge, campaign);
else
    profiles_struct = collect_profiles_by_utc_range(Merge, campaign, utc_range_file);
end

% Now remove any profiles that do not meet our criteria for sufficient
% sampling of the atmosphere
profiles_struct = remove_poor_quality_profiles(profiles_struct, varargin{:});
if isempty(profiles_struct)
    [profiles_final, profiles_struct] = format_output(profiles_struct);
    return
end

% Next match up profiles that have valid OMI pixels to compare against.
% Remove profiles that do not from the structure; add the SP and BEHR NO2
% columns to the profiles structure.
profiles_struct = match_profiles_to_omi(profiles_struct, Data, varargin{:});
if isempty(profiles_struct)
    [profiles_final, profiles_struct] = format_output(profiles_struct);
    return
end

% Finally we integrate the aircraft profile. This function also handles
% extrapolating the aircraft profiles to the surface and tropopause as
% needed. One of the things this function needs to know is whether it
% should use daily or monthly WRF profiles to do the extrapolation. 
profiles_struct = integrate_profiles(profiles_struct, Data, varargin{:});

profiles_final = format_output(profiles_struct);

%%%%%%%%%%%%%%%%%%%%%%%%
% PRIMARY SUBFUNCTIONS %
%%%%%%%%%%%%%%%%%%%%%%%%

    % These following two functions are nested to share the
    % "merge_variable_names" and "merge_variables" values.

    function profs = collect_profiles_by_number(Merge, campaign)
        merge_names = merge_field_names(campaign);
        
        
        prof_nums = remove_merge_fills(Merge, merge_names.profile_numbers);
        unique_prof_nums = unique(prof_nums);
        % Remove any random fill values that sneak through, and profile number 0
        % (which is the value given when not in a profile)
        unique_prof_nums(isnan(unique_prof_nums) | unique_prof_nums == 0) = [];
        
        profs = make_empty_struct_from_cell(merge_variable_names);
        profs.profile_id = '';
        profs.date = '';
        profs = repmat(profs, size(unique_prof_nums));
        
        for i_prof = 1:numel(unique_prof_nums)
            xx_profile = prof_nums == unique_prof_nums(i_prof);
            profs(i_prof).profile_id = num2str(unique_prof_nums(i_prof)); % convert to a string so that we can do the same for UTC ranges and have a generic profile ID that is always a string for formatting purposes
            profs(i_prof).date = Merge.metadata.date;
            for i_var = 1:numel(merge_variable_names)
                var_info = merge_variables.(merge_variable_names{i_var});
                values = remove_merge_fills(Merge, merge_names.(var_info.merge_fn), 'unit', var_info.unit, 'utc2datenum');
                profs(i_prof).(merge_variable_names{i_var}) = values(xx_profile);
            end
        end
        
    end

    function profs = collect_profiles_by_utc_range(Merge, campaign, utc_range_file)
        
        if ~exist(utc_range_file, 'file')
            % If a range file was given but does not appear to point to an
            % actual file, try giving it to merge_field_names as a regex.
            % This way the user can pass an abbreviated form of the file
            % name, and this will automatically get the full, correct path.
            [merge_names, ~, ~, utc_range_file] = merge_field_names(campaign, 'specified', utc_range_file);
        else
            merge_names = merge_field_names(campaign);
        end
        
        LoadedUTCRanges = load(utc_range_file);
        
        % utc_ranges.Ranges is a structure (each element is one day).
        % Ranges.Ranges is an n-by-2 matrix where the first column is the
        % beginning of a range of UTC values and the second column is the
        % end of that range. Therefore, we first need to find the right day
        % for our Merge file, then iterate over the ranges and extract the
        % values for that range.
        merge_dnum = datenum(Merge.metadata.date);
        for i_day = 1:numel(LoadedUTCRanges.Ranges)
            if datenum(LoadedUTCRanges.Ranges(i_day).Date) == merge_dnum
                utc_ranges = LoadedUTCRanges.Ranges(i_day).Ranges;
                break
            elseif i_day == numel(LoadedUTCRanges.Ranges)
                E.callError('utc_range_date', 'Could not find UTC ranges for %s in %s', Merge.metadata.date, utc_range_file);
            end
        end
        
        % Now this just needs to duplicate the profs structure created in
        % the other collect_profiles subfunction
        profs = make_empty_struct_from_cell(merge_variable_names);
        profs.profile_id = '';
        profs.date = '';
        profs = repmat(profs, size(utc_ranges,1),1);
        
        merge_utc = remove_merge_fills(Merge, merge_names.utc);
        for i_prof = 1:numel(profs)
            xx_profile = merge_utc >= utc_ranges(i_prof,1) & merge_utc <= utc_ranges(i_prof,2);
            profs(i_prof).profile_id = num2str(utc_ranges(i_prof,:)); 
            profs(i_prof).date = Merge.metadata.date;
            for i_var = 1:numel(merge_variable_names)
                var_info = merge_variables.(merge_variable_names{i_var});
                values = remove_merge_fills(Merge, merge_names.(var_info.merge_fn), 'unit', var_info.unit, 'utc2datenum');
                profs(i_prof).(merge_variable_names{i_var}) = values(xx_profile);
            end
        end
    end

end

function profs = remove_poor_quality_profiles(profs, varargin)
p = inputParser;
p.addParameter('min_radar_alt', 0.5);
p.addParameter('number_bl_points', 20);
p.addParameter('min_height', 0);
p.addParameter('DEBUG_LEVEL',2);
p.KeepUnmatched = true; % this lets us pass all the parameters from the main function down

p.parse(varargin{:});
pout = p.Results;

min_radar_alt = pout.min_radar_alt;
num_bl_points = pout.number_bl_points;
min_height = pout.min_height;
DEBUG_LEVEL = pout.DEBUG_LEVEL;

xx_valid_profs = true(size(profs));
bl_top_in_km = 3;
for i_prof = 1:numel(profs)
    in_bl = profs(i_prof).radar_alt < bl_top_in_km;
    
    num_points_in_bl = sum(~isnan(profs(i_prof).no2(in_bl)));
    bottom_radar_alt = min(profs(i_prof).radar_alt);
    profile_height = max(profs(i_prof).pressure_alt) - min(profs(i_prof).pressure_alt);
    if DEBUG_LEVEL > 3
        fprintf('Profile id %s:\n\t# points in bl = %d\n\tMin radar alt = %f\n\tProfile height = %f\n', profs(i_prof).profile_id, num_points_in_bl, bottom_radar_alt, profile_height);
    end
    
    if num_points_in_bl < num_bl_points
        xx_valid_profs(i_prof) = false;
        if DEBUG_LEVEL > 1; fprintf('Profile id %s rejected because there were fewer than %d points below %f km\n', profs(i_prof).profile_id, num_bl_points, bl_top_in_km); end
    elseif bottom_radar_alt > min_radar_alt
        xx_valid_profs(i_prof) = false;
        if DEBUG_LEVEL > 1; fprintf('Profile id %s rejected because the bottom of the profile was above the minimum required AGL distance (%f km)\n', profs(i_prof).profile_id, min_radar_alt); end
    elseif profile_height < min_height
        % I'm using pressure alt here because sometimes radar alt has NaNs,
        % possibly once it's more than a certain max distance above the
        % ground. Pressure altitude should be defined for whole profiles.
        xx_valid_profs(i_prof) = false;
        if DEBUG_LEVEL > 1; fprintf('Profile id %s rejected because the difference between the top and bottom of the profile (%f) was less than required (%f)\n', profs(i_prof).profile_id, profile_height, min_height); end
    else
        if DEBUG_LEVEL > 2; fprintf('Profile id %s accepted\n', profs(i_prof).profile_id); end
    end
end

profs(~xx_valid_profs) = [];

end


function profs = match_profiles_to_omi(profs, Data, varargin)
E = JLLErrors;
p = inputParser;
p.addParameter('time_range',1.5);
p.addParameter('match_bl_only', 0);
p.addParameter('DEBUG_LEVEL', 2);
p.KeepUnmatched = true;
p.parse(varargin{:});
pout = p.Results;

time_range = pout.time_range / 24; % convert from hours to days for use with date numbers
match_bl_only = pout.match_bl_only;
DEBUG_LEVEL = pout.DEBUG_LEVEL;

xx_matched = false(size(profs));
% We'll need to handle each orbit in Data separately. Go ahead and
% initialize empty arrays for the OMI NO2 columns. That way if a profile
% matches multiple pixels we can use a consistent concatenation op rather
% than having to check if the field exists.
profs(1).sp_no2 = [];
profs(1).behr_no2 = [];
profs(1).omi_area = []; % might use to weight the fit by which points use small pixels
profs(1).nasa_terpres = [];
profs(1).globe_terpres = []; % use to figure out how far we need to extrapolate the aircraft profile down to the surface.
profs(1).nasa_tropopause = []; % need for the upper integration limit
profs(1).wrf_tropopause = []; % need for the upper integration limit
profs(1).matched_pixels = [];
for i_orbit = 1:numel(Data)
    omi_loncorn = Data(i_orbit).FoV75CornerLongitude;
    omi_latcorn = Data(i_orbit).FoV75CornerLatitude;
    Data(i_orbit).Areaweight = ones(size(Data(i_orbit).Longitude));
    [sp_no2, behr_no2] = filter_bad_pixels(Data(i_orbit));
    mean_orbit_time = nanmean(omi_time_conv(Data(i_orbit).Time(:)));
    
    for i_prof = 1:numel(profs)
        % Are we only concerned with pixels that overlap the boundary layer
        % part of the profile?
        if match_bl_only > 0
            xx_bl = profs(i_prof).radar_alt < match_bl_only;
        else
            xx_bl = true(size(profs(i_prof).utc));
        end
        
        if sum(xx_bl(:)) == 0
            if DEBUG_LEVEL > 1; fprintf('Profile id %s not matched with orbit %d on %s because it has no points in below the requested BL height (%.2f)\n', profs(i_prof).profile_id, i_orbit, profs(i_prof).date, match_bl_only); end
            continue
        end
        
        % First check: is the profile within the requested time range of
        % this orbit? If not, we can skip it
        prof_mean_utc = nanmean(profs(i_prof).utc(xx_bl));
        if prof_mean_utc < mean_orbit_time - time_range || prof_mean_utc > mean_orbit_time + time_range
            if DEBUG_LEVEL > 1; fprintf('Profile id %s not matched with orbit %d on %s because it is outside the time range of %f hr\n', profs(i_prof).profile_id, i_orbit, profs(i_prof).date, time_range*24); end
            continue
        end
        
        % Next, does this profile overlap at least one valid pixel in
        % space? 
        xx_pix = pixels_overlap_profile(omi_loncorn, omi_latcorn, profs(i_prof).longitude(xx_bl), profs(i_prof).latitude(xx_bl), ~isnan(profs(i_prof).no2(xx_bl)), varargin{:});
        if sum(~isnan(sp_no2(xx_pix))) == 0 && sum(~isnan(behr_no2(xx_pix))) == 0
            if DEBUG_LEVEL > 1; fprintf('Profile id %s not matched with orbit %d on %s because it does not overlap any valid pixels\n', profs(i_prof).profile_id, i_orbit, profs(i_prof).date); end
            continue
        end
        
        % Add a structure keeping track of the individual pixels that
        % matched.
        matched_pixels = subset_behr_data_struct(Data(i_orbit), xx_pix);
        
        % Found at least one valid pixel overlapped by the profile. Now
        % average the overlapped pixels to generate our matched OMI VCDs.
        xx_matched(i_prof) = true;
        this_sp_vcd = nanmean(Data(i_orbit).ColumnAmountNO2Trop(xx_pix));
        this_behr_vcd = nanmean(Data(i_orbit).BEHRColumnAmountNO2Trop(xx_pix));
        % Unlike the VCDs, FoV75 area hasn't been set to NaN where the
        % pixels should not be used, so we want to only average it where
        % the NO2 data is used. Also, only one across track slice is given,
        % so we need to replicate that so that our indexing works.
        xx_goodpix = xx_pix & ~isnan(Data(i_orbit).ColumnAmountNO2Trop) & ~isnan(Data(i_orbit).BEHRColumnAmountNO2Trop);
        if isfield(Data, 'FoV75Area')
            orbit_area = repmat(Data(i_orbit).FoV75Area, size(Data(i_orbit).Longitude,1), 1);
            this_omi_area = nanmean(orbit_area(xx_goodpix));
        else
            this_omi_area = nan;
        end
        this_nasa_terpres = nanmean(Data(i_orbit).TerrainPressure(xx_goodpix));
        if isfield(Data, 'BEHRSurfacePressure') % this was implemented for testing the hyposmetric surface pressure correction
            this_globe_terpres = nanmean(Data(i_orbit).BEHRSurfacePressure(xx_goodpix));
        else
            this_globe_terpres = nanmean(Data(i_orbit).GLOBETerpres(xx_goodpix));
        end
        this_nasa_trop = nanmean(Data(i_orbit).TropopausePressure(xx_goodpix));
        if isfield(Data, 'BEHRTropopausePressure')
            this_wrf_trop = nanmean(Data(i_orbit).BEHRTropopausePressure(xx_goodpix));
        else
            % Assume that if there is no BEHR tropopause pressure specified
            % then we must be using an old version that would always be
            % integrated to 200 hPa.
            this_wrf_trop = 200 * ones(size(this_globe_terpres));
        end
        
        profs(i_prof).sp_no2 = veccat(profs(i_prof).sp_no2, this_sp_vcd);
        profs(i_prof).behr_no2 = veccat(profs(i_prof).behr_no2, this_behr_vcd);
        profs(i_prof).omi_area = veccat(profs(i_prof).omi_area, this_omi_area);
        profs(i_prof).globe_terpres = veccat(profs(i_prof).globe_terpres, this_globe_terpres);
        profs(i_prof).nasa_terpres = veccat(profs(i_prof).nasa_terpres, this_nasa_terpres);
        profs(i_prof).nasa_tropopause = veccat(profs(i_prof).nasa_tropopause, this_nasa_trop);
        profs(i_prof).wrf_tropopause = veccat(profs(i_prof).wrf_tropopause, this_wrf_trop);
        profs(i_prof).matched_pixels = veccat(profs(i_prof).matched_pixels, matched_pixels);
    end
end

% Remove unmatched profiles
profs(~xx_matched) = [];
end


function profs = integrate_profiles(profs, Data, varargin)
E = JLLErrors;

p = inputParser;
p.addParameter('prof_extension', 'extrap');
p.addParameter('DEBUG_LEVEL',2);
p.KeepUnmatched = true;
p.parse(varargin{:});
pout = p.Results;

prof_extension_mode = pout.prof_extension;

DEBUG_LEVEL = pout.DEBUG_LEVEL;

% Following Lamsal et al. 2014
% (https://www.atmos-chem-phys.net/14/11587/2014/acp-14-11587-2014.pdf), we
% will be using either our WRF or 2012 GEOS-Chem profiles both to insert at
% the top of the aircraft profile and to describe the extrapolation to the
% terrain. Load the WRF data now since it might take a while. The profile
% UTC should have been converted to date numbers, that will tell us which
% WRF file is closest in time to the aircraft profile.


keep_profs = true(size(profs));

for i_prof = 1:numel(profs)
    
    
    % Next we need to bin the profiles to the OMI pressure levels. (This
    % may need updated once we push the tropopause update.)
    [binned_prof, binned_pres] = bin_omisp_pressure(profs(i_prof).pressure, profs(i_prof).no2, 'median');
    
    if any(strcmpi(prof_extension_mode, {'wrf','geos'}))
        [binned_prof, binned_pres, is_appended_or_interpolated, keep_profs(i_prof)] = append_model_to_profile(binned_prof, binned_pres, profs(i_prof), Data, prof_extension_mode, varargin{:});
    elseif strcmpi(prof_extension_mode, 'extrap')
        [binned_prof, binned_pres, is_appended_or_interpolated, keep_profs(i_prof)] = extrapolate_profile(binned_prof, binned_pres, profs(i_prof), varargin{:});
    else
        E.badinput('Profile extension mode "%s" not recognized', prof_extension_mode);
    end
    
    if ~keep_profs(i_prof)
        continue
    end
    
    % There are rare cases where some model levels do not have
    % measurements. I assume this happens when with the 2-cell TD-LIF
    % instrument if the plane passes through an altitude bin while NO2
    % wasn't being measured. In any case, fill them in, but issue a warning
    % so we're aware of it.
    if any(isnan(binned_prof))
        warning('profile_integration:remaining_nans', 'NaNs remain in profile %s after extrapolating to surface and tropopause. Filling in by log-log interpolation', profs(i_prof).profile_id);
        is_nans = isnan(binned_prof);
        binned_prof(is_nans) = exp(interp1(log(binned_pres(~is_nans)), log(binned_prof(~is_nans)), log(binned_pres(is_nans))));
        is_appended_or_interpolated(is_nans) = 2;
    end
    
    % Finally we can integrate the model profile. By default, use the same
    % integrator as in the BEHR AMF calculation. We need to loop over all
    % the averaged matched pixels because each will have slightly
    % different surface and tropopause pressure.
    for i_match = 1:numel(profs(i_prof).globe_terpres)
        profs(i_prof).air_no2_nasa(i_match) = integPr2(binned_prof, binned_pres, profs(i_prof).nasa_terpres(i_match), profs(i_prof).nasa_tropopause(i_match), 'fatal_if_nans', true);
        profs(i_prof).air_no2_behr(i_match) = integPr2(binned_prof, binned_pres, profs(i_prof).globe_terpres(i_match), profs(i_prof).wrf_tropopause(i_match), 'fatal_if_nans', true);
    end
    % Add the binned profiles so that we can see exactly what profile is
    % being integrated.
    profs(i_prof).binned_profile = binned_prof;
    profs(i_prof).binned_pressure = binned_pres;
    % A value of 1 means it was appended by either extrapolation or WRF
    % insertion. A value of 2 means it was interpolated.
    profs(i_prof).is_appended_or_interpolated = is_appended_or_interpolated;
end

profs(~keep_profs) = [];

end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FUNCTIONS THAT EXTEND PROFILES TO SURFACE AND TROPOPAUSE %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [binned_prof, binned_pres, was_extrap, keep_this_prof] = extrapolate_profile(binned_prof, binned_pres, profs, varargin)
p = inputParser;
p.addParameter('detection_limit',3e-12);
p.addParameter('ignore_top_check',false);
p.addParameter('DEBUG_LEVEL',2);
p.KeepUnmatched = true;
p.parse(varargin{:});
pout = p.Results;

detection_limit = pout.detection_limit;
ignore_top_check = pout.ignore_top_check;
DEBUG_LEVEL = pout.DEBUG_LEVEL;

was_extrap = zeros(size(binned_prof));
keep_this_prof = true;

% Following Hains et al. 2010, extrapolate the top ten measurements to the
% top of the troposphere and the bottom ten to the bottom pressure bin.
[~, sort_permvec] = sort(profs.pressure_alt);
sorted_no2 = profs.no2(sort_permvec);
sorted_no2(isnan(sorted_no2)) = [];

bottom_ten_med = median(sorted_no2(1:10));
top_ten_med = median(sorted_no2(end-9:end));

if top_ten_med > 100e-12 && ~ignore_top_check
    % If the median of the top ten points is greater than 100 pptv, we may
    % not have gotten out of the boundary layer.
    fprintf('Profile %s removed because median of top ten points greater than 100 pptv\n', profs.profile_id);
    keep_this_prof = false;
    return
elseif top_ten_med < detection_limit
    % From Hains et al., they assume that if the NO2 concentration is below
    % the detection limit, it is equal to half the detection limit. By
    % default, this assumes the 3 pptv detection limit of the LIF from
    % INTEX-B.
    top_ten_med = 0.5*detection_limit;
end

last_not_nan = find(~isnan(binned_prof), 1, 'last');
top_nans = (last_not_nan+1):numel(binned_prof);
binned_prof(top_nans) = top_ten_med;
was_extrap(top_nans) = 1;

first_not_nan = find(~isnan(binned_prof), 1, 'first');
bottom_nans = 1:(first_not_nan-1);
binned_prof(bottom_nans) = bottom_ten_med;
was_extrap(bottom_nans) = 1;

end

function [binned_prof, binned_pres, is_from_model, keep_this_prof] = append_model_to_profile(binned_prof, binned_pres, profs, Data, model, varargin)
E = JLLErrors;

p = inputParser;
p.addParameter('wrf_prof_mode','');
p.addParameter('DEBUG_LEVEL', 2);
p.KeepUnmatched = true;
p.parse(varargin{:});
pout = p.Results;

wrf_prof_mode = pout.wrf_prof_mode;
if isempty(wrf_prof_mode)
    wrf_prof_mode = Data(1).BEHRProfileMode;
end
DEBUG_LEVEL = pout.DEBUG_LEVEL;

if strcmpi(model, 'wrf')
    model_data = load_wrf_profiles(nanmean(profs.utc), wrf_prof_mode);
elseif strcmpi(model, 'geos')
    model_data = load_gc_profiles(nanmean(profs.utc), varargin{:});
else
    E.badinput('No method defined to load data for model type "%s"', model);
end

% First we need to get the model profiles that overlap the aircraft
% profile. Fortunately, we can use the same logic as we did with OMI
% pixels.
xx_pix = pixels_overlap_profile(model_data.loncorn, model_data.latcorn, profs.longitude, profs.latitude, ~isnan(profs.no2), varargin{:});
model_avg_no2 = nanmean(model_data.no2(:,xx_pix),2);
model_avg_pres = nanmean(model_data.pres(:,xx_pix),2);
is_from_model = zeros(size(binned_prof));
keep_this_prof = true;
% We'll need the model profile interpolated to the profile pressure for
% both the top levels and the extrapolation to the ground. Like Bucsela
% et al. 2008, do log-log interpolation since pressure and
% concentration both roughly have exponential relationships to altitude

% If any of wrf_avg_pres is a NaN, that means that we are outside the
% model domain, and so in this mode, cannot integrate this profile. Such
% profiles would have to be evaluated with extrapolation.
if any(isnan(model_avg_pres))
    keep_this_prof = false;
    if DEBUG_LEVEL > 0
        fprintf('Profile %s removed because it falls outside the WRF domain\n', profs.profile_id);
    end
    return
end
wrf_interp_no2 = exp(interp1(log(model_avg_pres), log(model_avg_no2), log(binned_pres), 'linear', 'extrap'));

% We can fill in any points above the top of the measured profile
% simply by interpolating the average model profile to the binned
% pressures. Keep track of which parts of the profiles came from WRF
% and which from the aircraft.

last_non_nan = find(~isnan(binned_prof), 1, 'last');
binned_prof(last_non_nan+1:end) = wrf_interp_no2(last_non_nan+1:end);
is_from_model(last_non_nan+1:end) = 1;

% Now we need to extrapolate to the surface. Lamsal et al. 2014 does
% this by basically using the model profile ratio of the profile level
% where there is aircraft data to the desired pressure level,
% essentially using the modeled profile shape.
first_non_nan = find(~isnan(binned_prof), 1, 'first');
first_nans = 1:(first_non_nan-1);
model_ratios = wrf_interp_no2(first_nans) ./ wrf_interp_no2(first_non_nan);
binned_prof(first_nans) = model_ratios .* binned_prof(first_non_nan);
is_from_model(first_nans) = 1;
end

%%%%%%%%%%%%%%%%%%%%%%%%%%
% OTHER HELPER FUNCTIONS %
%%%%%%%%%%%%%%%%%%%%%%%%%%

function no2_field = set_no2_field(no2_field, campaign)
merge_names = merge_field_names(campaign);
% If an empty string is passed, try to find the valid name in those defined
% for this campaign.
if isempty(no2_field)
    if ~isempty(merge_names.no2_lif)
        no2_field = 'no2_lif';
    else
        no2_field = 'no2_ncar';
    end
    
    if isempty(merge_names.(no2_field))
        E.badinput('No NO2 field is defined in the Merge names for %s', campaign);
    end
% If something is passed, make sure it's something that is present in the
% Merge names
elseif ~isfield(merge_names, no2_field)
    E.badinput('''no2_field'' must be one of: %s', strjoin(fieldnames(merge_names), ', '));
% If it's present, make sure it's an actual Merge field name and not an
% empty string.
elseif isempty(merge_names.(no2_field))
    E.badinput('The "%s" NO2 field is not defined in the Merge names for %s', no2_field, campaign);
end


end

function [sp_no2, behr_no2] = filter_bad_pixels(Data)
Data = omi_pixel_reject(Data, 'detailed', struct('cloud_type', 'omi', 'cloud_frac', 0.2, 'row_anom_mode', 'XTrackFlags', 'check_behr_amf', true));
sp_no2 = Data.ColumnAmountNO2Trop;
behr_no2 = Data.BEHRColumnAmountNO2Trop;
xx_good = Data.Areaweight > 0;
sp_no2(~xx_good) = nan;
behr_no2(~xx_good) = nan;
end

function wrf_data = load_wrf_profiles(wrf_date, wrf_prof_mode)
wrf_file = find_wrf_path('us', wrf_prof_mode, wrf_date, 'fullpath');
wrf_lon = ncread(wrf_file, 'XLONG');
wrf_lat = ncread(wrf_file, 'XLAT');
[wrf_data.loncorn, wrf_data.latcorn] = wrf_grid_corners(wrf_lon, wrf_lat);

wrf_no2 = double(ncread(wrf_file, 'no2'));
wrf_no2_units = ncreadatt(wrf_file, 'no2', 'units');
wrf_data.no2 = convert_units(wrf_no2, wrf_no2_units, 'ppp');

wrf_data.pres = double(read_wrf_preproc(wrf_file, 'pres')); % returns pressure in hPa

% Permute the NO2 and pressure profiles to make indexing easier
wrf_data.no2 = permute(wrf_data.no2, [3 1 2]);
wrf_data.pres = permute(wrf_data.pres, [3 1 2]);

end

function gc_data = load_gc_profiles(aircraft_date, varargin)
p = inputParser;
p.addParameter('gc_data_dir','');
p.addParameter('gc_data_year',[]);
p.addParameter('gc_file_pattern','ts_12_14_satellite.%s.nc');
p.addParameter('gc_file_date_fmt', 'yyyymmdd');
p.KeepUnmatched = true;

p.parse(varargin{:});
pout = p.Results;

gc_data_dir = pout.gc_data_dir;
gc_data_year = pout.gc_data_year;
gc_file_pattern = pout.gc_file_pattern;
gc_file_date_fmt = pout.gc_file_date_fmt;

% If GEOS-chem year not given, assume that we have GEOS-Chem data for that
% specific year. Otherwise, assume we only have the year give.
if isempty(gc_data_year)
    gc_data_year = year(aircraft_date);
end

gc_date = datenum(gc_data_year, month(aircraft_date), day(aircraft_date));


% We want to use diagnostic 51 data output during OMI overpass. In my
% GEOS-Chem run, these are for between 12 and 14 local standard time, and
% are named ts_12_14_satellite.yyyymmdd.bpch, then translated to netCDF
% files by gc_nd51_to_ncdf.py in the GEOS-Chem-Utils repo.
gc_filename = fullfile(gc_data_dir, sprintf(gc_file_pattern, datestr(gc_date, gc_file_date_fmt)));

% We need the NO2 (converted to unscaled mixing ratio) along with lat/lon
% and pressure for coordinates. We will mimic the structure that we get
% from loading the WRF data so that this function can just be swapped with
% the WRF loading function.
gc_lonbounds = ncread(gc_filename, 'longitude_bounds');
gc_latbounds = ncread(gc_filename, 'latitude_bounds');

[gc_data.loncorn, gc_data.latcorn] = geos_latlon_bounds_to_corners(gc_lonbounds, gc_latbounds, 'format', 'pixel');

gc_no2 = ncread(gc_filename, 'TIME-SER_NO2');
gc_no2_units = ncreadatt(gc_filename, 'TIME-SER_NO2', 'units');
gc_data.no2 = convert_units(gc_no2, gc_no2_units, 'ppp');

% GEOS-Chem pressure is given on the edges of the grid cells, but the ND51
% diagnostic does not seem to provide the top most level. To get pressure
% at the center of the grid cells, we'll append the top 0 hPa level that
% is omitted (according to the "Ap" global attribute)

extra_pressure = zeros(size(gc_no2,1), size(gc_no2,2));
gc_pres = cat(3, ncread(gc_filename, 'PEDGE-$_PSURF'), extra_pressure);
gc_pres_units = ncreadatt(gc_filename, 'PEDGE-$_PSURF', 'units');
gc_pres = convert_units(gc_pres, gc_pres_units, 'hPa');
gc_data.pres = (gc_pres(:,:,1:end-1,:) + gc_pres(:,:,2:end,:))/2;

% Permute the NO2 and pressure profiles to make indexing easier. They
% should not have length(time) > 1
gc_data.no2 = permute(gc_data.no2, [3,1,2]);
gc_data.pres = permute(gc_data.pres, [3,1,2]);

end

function [profs_final, profs] = format_output(profs)
% If all the profiles have been removed, then we need to return an empty
% structure that matches the organization of what would be returned if
% there was at least one profile.
profs_req_fields = {'longitude', 'latitude', 'pressure', 'pressure_alt', 'radar_alt', 'no2', 'utc', 'profile_id', 'date', 'sp_no2', 'behr_no2', 'omi_area',...
        'nasa_terpres', 'globe_terpres', 'nasa_tropopause', 'wrf_tropopause', 'matched_pixels', 'air_no2_nasa', 'air_no2_behr', 'binned_profile', 'binned_pressure',...
        'is_appended_or_interpolated'};
if isempty(profs)
    profs_final = struct('sp_no2', [], 'behr_no2', [], 'air_no2_nasa', [], 'air_no2_behr', [], 'omi_area', [], 'profile_ids', {{}}, 'profile_dates', {{}}, 'profile_lon', [], 'profile_lat', []);
    % Make sure that profs always has the same fields no matter when the
    % function returns. Update this as necessary if adding more fields to
    % profs.
    profs = make_empty_struct_from_cell(profs_req_fields);
    return
else
    % Check that profs has the fields we're expecting - if not, we may need
    % to update this function.
    actual_fields = fieldnames(profs);
    % strcmp is very particular that arrays be the same size, so force both
    % to be column vectors.
    actual_fields = actual_fields(:);
    profs_req_fields = profs_req_fields(:);
    if ~isequal(size(actual_fields), size(profs_req_fields)) || any(~strcmp(actual_fields, profs_req_fields))
        field_list = sprintf('  Expected: %s\n  Actual: %s\n', strjoin(profs_req_fields, ', '),  strjoin(fieldnames(profs), ', '));
        warning('The fieldnames in PROFS is not what''s expected in FORMAT_OUTPUT(). This may mean you need to update the profs_req_fields variable in this function.\n%s', field_list);
    end
end


% The NO2 columns are easy, just concatenate all the profiles elements into
% a column vector

profs_final.sp_no2 = veccat(profs.sp_no2, 'column');
profs_final.behr_no2 = veccat(profs.behr_no2, 'column');
profs_final.air_no2_nasa = veccat(profs.air_no2_nasa, 'column');
profs_final.air_no2_behr = veccat(profs.air_no2_behr, 'column');
profs_final.omi_area = veccat(profs.omi_area, 'column');

% Profile lon and lat are given at 1s resolution in the profiles, average
% that down. Profile ids and dates don't need averaged, but do need
% expanded to match the number of comparisons made against each profile.
default_cell = cell(size(profs_final.sp_no2));
default_mat = nan(size(profs_final.sp_no2));
profs_final.profile_ids = default_cell;
profs_final.profile_dates = default_cell;
profs_final.profile_lon = default_mat;
profs_final.profile_lat = default_mat;

i_out = 1;
for i_prof = 1:numel(profs)
    for i_match = 1:numel(profs(i_prof).sp_no2)
        profs_final.profile_ids{i_out} = profs(i_prof).profile_id;
        profs_final.profile_dates{i_out} = profs(i_prof).date;
        profs_final.profile_lon(i_out) = nanmean(profs(i_prof).longitude);
        profs_final.profile_lat(i_out) = nanmean(profs(i_prof).latitude);
        
        i_out = i_out + 1;
    end
end
end
